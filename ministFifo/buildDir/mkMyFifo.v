//
// Generated by Bluespec Compiler (build 14ff62d)
//
// On Thu Jun 15 20:33:20 PDT 2023
//
//
// Ports:
// Name                         I/O  size props
// notFull                        O     1
// RDY_notFull                    O     1 const
// RDY_enq                        O     1
// notEmpty                       O     1
// RDY_notEmpty                   O     1 const
// RDY_deq                        O     1
// first                          O    32 reg
// RDY_first                      O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// enq_x                          I    32 reg
// EN_enq                         I     1
// EN_deq                         I     1
//
// Combinational paths from inputs to outputs:
//   EN_enq -> notEmpty
//   EN_enq -> RDY_deq
//   EN_enq -> RDY_first
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMyFifo(CLK,
		RST_N,

		notFull,
		RDY_notFull,

		enq_x,
		EN_enq,
		RDY_enq,

		notEmpty,
		RDY_notEmpty,

		EN_deq,
		RDY_deq,

		first,
		RDY_first);
  input  CLK;
  input  RST_N;

  // value method notFull
  output notFull;
  output RDY_notFull;

  // action method enq
  input  [31 : 0] enq_x;
  input  EN_enq;
  output RDY_enq;

  // value method notEmpty
  output notEmpty;
  output RDY_notEmpty;

  // action method deq
  input  EN_deq;
  output RDY_deq;

  // value method first
  output [31 : 0] first;
  output RDY_first;

  // signals for module outputs
  wire [31 : 0] first;
  wire RDY_deq,
       RDY_enq,
       RDY_first,
       RDY_notEmpty,
       RDY_notFull,
       notEmpty,
       notFull;

  // register bypassFifo_data
  reg [31 : 0] bypassFifo_data;
  wire [31 : 0] bypassFifo_data$D_IN;
  wire bypassFifo_data$EN;

  // register bypassFifo_empty_ehrReg
  reg bypassFifo_empty_ehrReg;
  wire bypassFifo_empty_ehrReg$D_IN, bypassFifo_empty_ehrReg$EN;

  // register bypassFifo_full_ehrReg
  reg bypassFifo_full_ehrReg;
  wire bypassFifo_full_ehrReg$D_IN, bypassFifo_full_ehrReg$EN;

  // ports of submodule bypassFifo_empty_virtual_reg_0
  wire bypassFifo_empty_virtual_reg_0$D_IN, bypassFifo_empty_virtual_reg_0$EN;

  // ports of submodule bypassFifo_empty_virtual_reg_1
  wire bypassFifo_empty_virtual_reg_1$D_IN,
       bypassFifo_empty_virtual_reg_1$EN,
       bypassFifo_empty_virtual_reg_1$Q_OUT;

  // ports of submodule bypassFifo_full_virtual_reg_0
  wire bypassFifo_full_virtual_reg_0$D_IN,
       bypassFifo_full_virtual_reg_0$EN,
       bypassFifo_full_virtual_reg_0$Q_OUT;

  // ports of submodule bypassFifo_full_virtual_reg_1
  wire bypassFifo_full_virtual_reg_1$D_IN,
       bypassFifo_full_virtual_reg_1$EN,
       bypassFifo_full_virtual_reg_1$Q_OUT;

  // rule scheduling signals
  wire CAN_FIRE_RL_bypassFifo_empty_canonicalize,
       CAN_FIRE_RL_bypassFifo_full_canonicalize,
       CAN_FIRE_deq,
       CAN_FIRE_enq,
       WILL_FIRE_RL_bypassFifo_empty_canonicalize,
       WILL_FIRE_RL_bypassFifo_full_canonicalize,
       WILL_FIRE_deq,
       WILL_FIRE_enq;

  // value method notFull
  assign notFull =
	     bypassFifo_full_virtual_reg_1$Q_OUT ||
	     bypassFifo_full_virtual_reg_0$Q_OUT ||
	     !bypassFifo_full_ehrReg ;
  assign RDY_notFull = 1'd1 ;

  // action method enq
  assign RDY_enq = notFull ;
  assign CAN_FIRE_enq = notFull ;
  assign WILL_FIRE_enq = EN_enq ;

  // value method notEmpty
  assign notEmpty =
	     bypassFifo_empty_virtual_reg_1$Q_OUT || EN_enq ||
	     !bypassFifo_empty_ehrReg ;
  assign RDY_notEmpty = 1'd1 ;

  // action method deq
  assign RDY_deq = notEmpty ;
  assign CAN_FIRE_deq = notEmpty ;
  assign WILL_FIRE_deq = EN_deq ;

  // value method first
  assign first = bypassFifo_data ;
  assign RDY_first = notEmpty ;

  // submodule bypassFifo_empty_virtual_reg_0
  RevertReg #(.width(32'd1),
	      .init(1'd0)) bypassFifo_empty_virtual_reg_0(.CLK(CLK),
							  .D_IN(bypassFifo_empty_virtual_reg_0$D_IN),
							  .EN(bypassFifo_empty_virtual_reg_0$EN),
							  .Q_OUT());

  // submodule bypassFifo_empty_virtual_reg_1
  RevertReg #(.width(32'd1),
	      .init(1'd0)) bypassFifo_empty_virtual_reg_1(.CLK(CLK),
							  .D_IN(bypassFifo_empty_virtual_reg_1$D_IN),
							  .EN(bypassFifo_empty_virtual_reg_1$EN),
							  .Q_OUT(bypassFifo_empty_virtual_reg_1$Q_OUT));

  // submodule bypassFifo_full_virtual_reg_0
  RevertReg #(.width(32'd1),
	      .init(1'd0)) bypassFifo_full_virtual_reg_0(.CLK(CLK),
							 .D_IN(bypassFifo_full_virtual_reg_0$D_IN),
							 .EN(bypassFifo_full_virtual_reg_0$EN),
							 .Q_OUT(bypassFifo_full_virtual_reg_0$Q_OUT));

  // submodule bypassFifo_full_virtual_reg_1
  RevertReg #(.width(32'd1),
	      .init(1'd0)) bypassFifo_full_virtual_reg_1(.CLK(CLK),
							 .D_IN(bypassFifo_full_virtual_reg_1$D_IN),
							 .EN(bypassFifo_full_virtual_reg_1$EN),
							 .Q_OUT(bypassFifo_full_virtual_reg_1$Q_OUT));

  // rule RL_bypassFifo_empty_canonicalize
  assign CAN_FIRE_RL_bypassFifo_empty_canonicalize = 1'd1 ;
  assign WILL_FIRE_RL_bypassFifo_empty_canonicalize = 1'd1 ;

  // rule RL_bypassFifo_full_canonicalize
  assign CAN_FIRE_RL_bypassFifo_full_canonicalize = 1'd1 ;
  assign WILL_FIRE_RL_bypassFifo_full_canonicalize = 1'd1 ;

  // register bypassFifo_data
  assign bypassFifo_data$D_IN = enq_x ;
  assign bypassFifo_data$EN = EN_enq ;

  // register bypassFifo_empty_ehrReg
  assign bypassFifo_empty_ehrReg$D_IN =
	     EN_deq || !EN_enq && bypassFifo_empty_ehrReg ;
  assign bypassFifo_empty_ehrReg$EN = 1'd1 ;

  // register bypassFifo_full_ehrReg
  assign bypassFifo_full_ehrReg$D_IN =
	     !EN_deq && (EN_enq || bypassFifo_full_ehrReg) ;
  assign bypassFifo_full_ehrReg$EN = 1'd1 ;

  // submodule bypassFifo_empty_virtual_reg_0
  assign bypassFifo_empty_virtual_reg_0$D_IN = 1'd0 ;
  assign bypassFifo_empty_virtual_reg_0$EN = EN_enq ;

  // submodule bypassFifo_empty_virtual_reg_1
  assign bypassFifo_empty_virtual_reg_1$D_IN = 1'd0 ;
  assign bypassFifo_empty_virtual_reg_1$EN = EN_deq ;

  // submodule bypassFifo_full_virtual_reg_0
  assign bypassFifo_full_virtual_reg_0$D_IN = 1'd0 ;
  assign bypassFifo_full_virtual_reg_0$EN = EN_enq ;

  // submodule bypassFifo_full_virtual_reg_1
  assign bypassFifo_full_virtual_reg_1$D_IN = 1'd0 ;
  assign bypassFifo_full_virtual_reg_1$EN = EN_deq ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        bypassFifo_empty_ehrReg <= `BSV_ASSIGNMENT_DELAY 1'd1;
	bypassFifo_full_ehrReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (bypassFifo_empty_ehrReg$EN)
	  bypassFifo_empty_ehrReg <= `BSV_ASSIGNMENT_DELAY
	      bypassFifo_empty_ehrReg$D_IN;
	if (bypassFifo_full_ehrReg$EN)
	  bypassFifo_full_ehrReg <= `BSV_ASSIGNMENT_DELAY
	      bypassFifo_full_ehrReg$D_IN;
      end
    if (bypassFifo_data$EN)
      bypassFifo_data <= `BSV_ASSIGNMENT_DELAY bypassFifo_data$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bypassFifo_data = 32'hAAAAAAAA;
    bypassFifo_empty_ehrReg = 1'h0;
    bypassFifo_full_ehrReg = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMyFifo

